#pragma once
#include<stdexcept>
#include <iostream>
using std::cout;
using std::endl;
using namespace std;
// DO NOT EDIT THIS FILE IN ANY WAY

// Node class for Linked List
template <class X>

class NodeT
{
public:
	X data;
	//NodeT* previous;
	NodeT* next;
    NodeT(){
        //data = new X;
        next = nullptr;
    }
	NodeT(X val, NodeT* nxt) : data(val), next(nxt) {};
	NodeT(X val) : data(val), next(nullptr) {};
	//NodeT(): next(nullptr) {};
};

template <class X>
class QueueT
{
public:
	// Constructors, destructor and overloaded op=
	QueueT();
	QueueT(const QueueT & dq){
        n = dq.n;

        front = new NodeT<X>;
        *front = *(dq.front);
        //this->front = dq->front;
        //this->back = dq->back;
        back = new NodeT<X>;
        *back = *(dq.back);
        //return *this;
	};
	~QueueT();

	// Mutators
	// PARAM: val = value to be inserted
	// POST: inserts val at the front of the QueueT
	void enqueue(X val);
	// PARAM: val = value to be inserted
	// POST: inserts val at the back of the QueueT
	X dequeue();

	// POST: removes node at the front of the QueueT and returns its data
	//int remove_front();
	// POST: removes node at the back of the QueueT and returns its data
	//int remove_back();

	// POST: returns the number values stored in the QueueT
	int size() const;
	// POST: returns T iff QueueT is empty
	bool empty() const;
	// POST: Prints contents of QueueT from front to back
	void print() const;
	NodeT<X>* getFront() const;
    QueueT<X> & operator=(const QueueT<X> & dq);
	QueueT<X> merge(const QueueT &dq);
	void concatenate(QueueT &dq, int sz);


private:
	int n;
	NodeT<X>* front;
	NodeT<X>* back;

	// PARAM: dq = QueueT to be copied
	// POST: calling object is made a copy of dq
	void copyQueueT(const QueueT & dq);

	// PRE: original and copy are appropriate pointers
	// PARAM: original = pointer to a node in a QueueT being copied
	//        copy = pointer to a node in the calling object
	// POST: calling object is made a copy of dq
	//void copyNode(NodeT* original, NodeT* copy);

	// Deallocates all dynamic memory associated with calling object
	void removeAll();
	void copyDeque(const QueueT & dq);
	void setter(int n);
};

template<class X>
QueueT<X>::QueueT()
{
	front = back = nullptr;
	n = 0;
}


template<class X>
QueueT<X> & QueueT<X>::operator=(const QueueT<X> &dq)
{
    if(this == &dq) return *this;
    removeAll();
    NodeT<X> *tem;

    copyDeque(dq);
    tem = front;

    return *this;
}

template<class X>
void QueueT<X>::removeAll()
{
	NodeT<X>* temp = front;
	while (front != nullptr) {
		front = temp->next;
		delete temp;
		temp = front;
	}
	n = 0;
	front = back = nullptr;
}

template<class X>
void QueueT<X>::copyDeque(const QueueT<X> & dq)
{
    n = dq.n;
    front = new NodeT<X>;
    *front = *(dq.front);
    back = new NodeT<X>;
    *back = *(dq.back);
}

template<class X>
QueueT<X>::~QueueT()
{
	//cout << "... in destructor ..."; // debug print
	removeAll();
}


template<class X>
void QueueT<X>::enqueue(X val)
{
	// QueueT is empty
	if (back == nullptr) {
		back = new NodeT<X>(val);
		front = back;
	}
	else {
		back->next = new NodeT<X>(val);
		//back->next->previous = back;
		back = back->next;
	}
	n++;
}

template<class X>
X QueueT<X>::dequeue()
{
	// QueueT is empty
	if (front == nullptr) {
		throw runtime_error("remove_back failed - empty");
	}

    if(front == back){
        X result = back->data;
        front = nullptr;
        back = nullptr;
        n--;
        return result;
    }
	X result = front->data;
	NodeT<X> *temp = front;
	front = front->next;
	n--;
	delete temp;
	return result;
}

template<class X>
QueueT<X> QueueT<X>:: merge(const QueueT &dq)
{
    QueueT<X> ret;
    ret.front = this->front;
    ret.back = this->back;
    ret.n = this->n;
    int counter = n;
    NodeT<X> *tem;
    tem = ret.front;
    tem = dq.front;
    while(tem!=nullptr){
        ret.back->next = new NodeT<X>;
        ret.back->next=tem;
        ret.back = tem;
        tem=tem->next;
        ++counter;
    }
    ret.n = counter;
    tem = this->front;
    return ret;
}



template<class X>
void QueueT<X>:: concatenate(QueueT &dq, int sz)
{
    if(dq.n<sz){
        throw runtime_error("request for invalid concatenation__not enough elements to concate");
        return;
    }
    //QueueT<X> qq(dq);
    dq.n = dq.n - sz;

    n+=sz;
    int cc = 1;
    NodeT<X> *tem, *dqtem;
    tem = back;
    dqtem = dq.front;
    while(cc<=sz){
        tem->next = new NodeT<X>;
        tem->next = dqtem;
        dqtem = dqtem->next;
        tem=tem->next;
        cc++;
    }
    back = tem;

    dq.front = dqtem;
    if(dq.n==0){
        dq.front = nullptr;
        dq.back = nullptr;
    }
}

template<class X>
int QueueT<X>::size() const
{
	return n;
}

template<class X>
bool QueueT<X>::empty() const
{
    return front == nullptr && back == nullptr;
}

template<class X>
void QueueT<X>::print() const
{
	NodeT<X> *p = front;
	while (p != nullptr) {
		cout << p->data << " ";
		p = p->next;
        if(p == nullptr) break;

	}
}

template<class X>
NodeT<X>* QueueT<X>::getFront() const
{
	// QueueT is empty
	if (front == nullptr) {
		throw runtime_error("queue is empty");
	}
    NodeT<X> *node;
	node=front;
	return node;
}
